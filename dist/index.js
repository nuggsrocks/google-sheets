"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});async function y(t){const e=await(await fetch(t)).text();return JSON.parse(e.substring(e.indexOf("{"),e.lastIndexOf("}")+1))}function _(t){return t.trim().replace(/[^a-zA-Z0-9]+(.)/g,(r,e)=>e.toUpperCase()).replace(/^[A-Z]/,r=>r.toLowerCase())}function h(t){const r=t.trim().replace(/[_-]+/g," ").replace(/([a-z0-9])([A-Z])/g,"$1 $2").replace(/\s+/g," ").toLowerCase();return r?r.replace(/\b[a-z]/g,e=>e.toUpperCase()):""}function b(t,r,e){function s(n,o){if(n._zod||Object.defineProperty(n,"_zod",{value:{def:o,constr:a,traits:new Set},enumerable:!1}),n._zod.traits.has(t))return;n._zod.traits.add(t),r(n,o);const l=a.prototype,f=Object.keys(l);for(let c=0;c<f.length;c++){const d=f[c];d in n||(n[d]=l[d].bind(n))}}const u=e?.Parent??Object;class i extends u{}Object.defineProperty(i,"name",{value:t});function a(n){var o;const l=e?.Parent?new i:this;s(l,n),(o=l._zod).deferred??(o.deferred=[]);for(const f of l._zod.deferred)f();return l}return Object.defineProperty(a,"init",{value:s}),Object.defineProperty(a,Symbol.hasInstance,{value:n=>e?.Parent&&n instanceof e.Parent?!0:n?._zod?.traits?.has(t)}),Object.defineProperty(a,"name",{value:t}),a}function g(t,r){return typeof r=="bigint"?r.toString():r}const v=(t,r)=>{t.name="$ZodError",Object.defineProperty(t,"_zod",{value:t._zod,enumerable:!1}),Object.defineProperty(t,"issues",{value:r,enumerable:!1}),t.message=JSON.stringify(r,g,2),Object.defineProperty(t,"toString",{value:()=>t.message,enumerable:!1})},j=b("$ZodError",v);function O(t,r=e=>e.message){const e={},s=[];for(const u of t.issues)u.path.length>0?(e[u.path[0]]=e[u.path[0]]||[],e[u.path[0]].push(r(u))):s.push(r(u));return{formErrors:s,fieldErrors:e}}function w(t,r=e=>e.message){const e={_errors:[]},s=u=>{for(const i of u.issues)if(i.code==="invalid_union"&&i.errors.length)i.errors.map(a=>s({issues:a}));else if(i.code==="invalid_key")s({issues:i.issues});else if(i.code==="invalid_element")s({issues:i.issues});else if(i.path.length===0)e._errors.push(r(i));else{let a=e,n=0;for(;n<i.path.length;){const o=i.path[n];n===i.path.length-1?(a[o]=a[o]||{_errors:[]},a[o]._errors.push(r(i))):a[o]=a[o]||{_errors:[]},a=a[o],n++}}};return s(t),e}function S(t){const r=[],e=t.map(s=>typeof s=="object"?s.key:s);for(const s of e)typeof s=="number"?r.push(`[${s}]`):typeof s=="symbol"?r.push(`[${JSON.stringify(String(s))}]`):/[^\w$]/.test(s)?r.push(`[${JSON.stringify(s)}]`):(r.length&&r.push("."),r.push(s));return r.join("")}function E(t){const r=[],e=[...t.issues].sort((s,u)=>(s.path??[]).length-(u.path??[]).length);for(const s of e)r.push(`✖ ${s.message}`),s.path?.length&&r.push(`  → at ${S(s.path)}`);return r.join(`
`)}var m;class z{constructor(){this._map=new WeakMap,this._idmap=new Map}add(r,...e){const s=e[0];return this._map.set(r,s),s&&typeof s=="object"&&"id"in s&&this._idmap.set(s.id,r),this}clear(){return this._map=new WeakMap,this._idmap=new Map,this}remove(r){const e=this._map.get(r);return e&&typeof e=="object"&&"id"in e&&this._idmap.delete(e.id),this._map.delete(r),this}get(r){const e=r._zod.parent;if(e){const s={...this.get(e)??{}};delete s.id;const u={...s,...this._map.get(r)};return Object.keys(u).length?u:void 0}return this._map.get(r)}has(r){return this._map.has(r)}}function $(){return new z}(m=globalThis).__zod_globalRegistry??(m.__zod_globalRegistry=$());const P=(t,r)=>{j.init(t,r),t.name="ZodError",Object.defineProperties(t,{format:{value:e=>w(t,e)},flatten:{value:e=>O(t,e)},addIssue:{value:e=>{t.issues.push(e),t.message=JSON.stringify(t.issues,g,2)}},addIssues:{value:e=>{t.issues.push(...e),t.message=JSON.stringify(t.issues,g,2)}},isEmpty:{get(){return t.issues.length===0}}})},Z=b("ZodError",P);function C(t,r,e){const s=[],u=t.table,i=u.cols.map(o=>_(o.label)),a=r.toJSONSchema().required??[];a.forEach(o=>{if(!i.includes(o))throw new Error(`The sheet headers were edited. Column ${h(o)} was renamed or removed.`)}),i.forEach(o=>{a.includes(o)||e?.errorLogger&&e.errorLogger(`Unknown header "${h(o)}". Ignoring.`)});const n=i.filter(o=>a.includes(o));return u.rows.forEach((o,l)=>{const f={};n.forEach((c,d)=>{const p=o.c[d]?.v;p==null?f[c]=null:f[c]=p});try{const c=r.parse(f);s.push(c)}catch(c){e?.errorLogger&&c instanceof Z&&e.errorLogger(`❌ Invalid row at index ${l}`,E(c))}}),s}exports.fetchSheetJson=y;exports.parseSheet=C;exports.toCamelCase=_;exports.toHumanReadable=h;
